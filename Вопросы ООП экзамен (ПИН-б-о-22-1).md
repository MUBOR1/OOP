Алгоритмические конструкции языка. Условный оператор if. Цикл while. Цикл for. Mutable range-based for
Функции. Объявление функции. Возвращаемое значение. Передача параметров по значению. Передача параметров по ссылке. Передача параметров по константной ссылке. Модификатор const как защита от случайных изменений
Контейнеры. Vector. Map. Set
Алгоритмы. Вычисление минимума и максимума. Сортировка. Подсчет кол-ва вхождений конкретного элемента. Подсчет кол-ва элементов, которые удовлетворяют некоторому условию
Лямбда-выражения
Видимость и инициализация переменных. Видимость переменных
Видимость и инициализация переменных. Инициализация переменных.
Структуры.Создание структур. Вложенные структуры. Область видимости типа. Значение по умолчанию для полей структур
Классы. Приватная секция.. Методы. Контроль консистентности. Константные методы
Классы. Параметризированные конструкторы. Конструкторы по умолчанию, использование конструкторов. Деструкторы.Время жизни объекта
ООП: Примеры. Класс Function: Описание проблемы. Описание. Реализация. Использование.
Работа с текстовыми файлами. Потоки в С++. Чтение из потока. Запись в поток
Форматирование вывода. Файлы манипуляторы.
Перегрузка операторов для пользовательских типов. Тип Duration. Перегрузка оператора вывода в поток. Перегрузка оператора ввода из потока. 
Конструктор по умолчанию. Перегрузка арифметических операций. Сортировка. Перегрузка операторов сравнения. 
Использование перегруженных операторов в собственных структурах (пример практической практической реализации на основе своего варианта задания из л/р)
Исключения в С++. Обработка исключений. Блок try/catch
Целочисленные типы. Преобразование целочисленных типов. Безопасное использование.
Кортежи и пары. Возврат нескольких значений из функции.
Шаблоны функций. Универсальные функции вывода контейнеров в поток. Указание шаблонного параметра-типа.
Тестирование и отладка. Введение в юнит-тестирование.Декомпозиция. Создание юнит-тестов. Отладка. Анализ недостатков юнит-тестов.
Собственный фреймворк юнит-тестов. Улучшенный assert. Шаблон AssertEqual. Изолированный и регулярный запуск отдельных тестов.
Общие рекомендации по декомпозиции программы и написанию юнит-тестов.
Разделение кода по файлам. Механизм работы директивы #include. Обеспечение независимости заголовочных файлов. Понятие обьявления и определения функции(метода)
Механизм сборки проектов. Правила одного определения.
Наследование. Доступ к полям классов. Списки инициализации. Порядок конструирования экземпляра классов
Полиморфизм. Виртуальные методы. Абстрактные классы. Виртуальные методы и передача объектов по ссылке. Хранение объектов разных типов в контейнере с помощью shared_ptr.
Макросы. Оператор #. Макросы __FILE__ и __LINE__. Ошибки при использовании макросов.
Шаблоны классов. 
Интеграция пользовательского класса в цикл for
Разница между шаблоном и классом.
Вывод типов в шаблонах классов
Автоматический вывод типа, возвращаемого функцией
Принципы(правила) оптимизации кода.
Разработка и модификация своего собственного профайлера.
Эффективное использование потоков ввода/вывода. Буферизация в выходных потоках. Использование endl или '\n'. Связанность потоков
Сложность алгоритмов. Оценка сложности. Практические применения. Амортизированная сложность
Модель памяти в C++. Введение в модель памяти. Стек. Куча
Модель памяти в С++. Оператор new. Оператор delete. new и delete для объектов классового типа. Операторы new[] и delete[]
Модель памяти в С++. Введение в арифметику указателей. Добавляем в вектор begin и end. 
Модель памяти в С++. Константный указатель и указатель на константу
Эффективное использование линейных контейнеров. Эффективное использование вектора. Инвалидация ссылок.
Эффективное использование линейных контейнеров. Эффективное использование дека. Инвалидация итераторов
Эффективное использование линейных контейнеров. Контейнер list
Эффективное использование линейных контейнеров. Контейнер array
Эффективное использование линейных контейнеров. Класс string_view
Move-семантика. Перемещение временных объектов. Перемещение в других ситуациях. Функция move. 
Move-семантика. Конструктор копирования и оператор присваивания. Конструктор перемещения и перемещающий оператор присваивания. Передача параметра по значению. 
Move-семантика. Move-итераторы. Некопируемые типы. NRVO и copy elision. Опасности return
Базовая многопоточность. async и future. Задача генерации и суммирования матрицы. Особенности шаблона future. Состояние гонки. mutex и lock_guard. <execution>
Эффективное использование ассоциативных контейнеров. Размен отсортированности на производительность. Внутреннее устройство ассоциативных контейнеров. 
Эффективное использование ассоциативных контейнеров. Внутреннее устройство unordered_map и unordered_set
Эффективное использование ассоциативных контейнеров. Внутреннее устройство map и set
Эффективное использование ассоциативных контейнеров. Итераторы в map. Почему лучше использовать собственные методы для поиска. Итераторы в unordered_map. Инвалидация итераторов в ассоциативных контейнерах
Использование пользовательских типов в ассоциативных контейнерах. Зависимость производительности от хеш-функции. Рекомендации по выбору хеш-функции. map::extract и map::merge
Пространства имён. Учебный пример. Проблема пересечения имён двух разных библиотек
Знакомство с пространствами имён Особенности синтаксиса пространств имён.Using-декларация. Директива using namespace. 
Глобальное пространство имён. Using namespace в заголовочных файлах.
Пространство имён std. Структурирование кода с использованием пространств имён. Рекомендации по использованию пространств имён
Указатель this. Присваивание объекта самому себе. this как неявный параметр методов класса
